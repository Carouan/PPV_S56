/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => EasyKeepViewPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  mySetting: "default",
  notesDB: [],
  openAsHomepage: false
};
var EasySettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Use easy keep view as home page").setDesc("Automatically open easy keep view when obsidian starts").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.openAsHomepage);
      toggle.onChange(async (value) => {
        this.plugin.settings.openAsHomepage = value;
        await this.plugin.saveSettings();
        new import_obsidian.Notice("Restart obsidian to apply the homepage setting.");
      });
    });
  }
};

// src/main.ts
var VIEW_TYPE_EASY_KEEP = "easy-keep-view";
function resolveImageByName(app, imageName) {
  const target = imageName.replace(/\.(jpg|jpeg|png|webp)$/i, "").toLowerCase();
  const candidates = app.vault.getFiles().filter((f) => /\.(jpg|jpeg|png|webp)$/i.test(f.name));
  for (const file of candidates) {
    if (file.basename.toLowerCase() === target) {
      return file;
    }
  }
  return null;
}
var EasyKeepView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.cardContainer = null;
    this.cards = /* @__PURE__ */ new Map();
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_EASY_KEEP;
  }
  getDisplayText() {
    return "Easy keep view";
  }
  createOrUpdateCard(note) {
    let card = this.cards.get(note.path);
    if (!card) {
      card = this.cardContainer.createDiv("easy-keep-card");
      this.cards.set(note.path, card);
    } else {
      card.empty();
    }
    card.createEl("h3", { text: note.title });
    if (note.imageLink) {
      let file = this.app.metadataCache.getFirstLinkpathDest(note.imageLink, note.path);
      if (!(file instanceof import_obsidian2.TFile)) {
        file = resolveImageByName(this.app, note.imageLink);
      }
      if (file instanceof import_obsidian2.TFile) {
        const resourcePath = this.app.vault.getResourcePath(file);
        const img = card.createEl("img", { cls: "easy-keep-thumbnail" });
        img.src = resourcePath;
        img.onerror = () => {
          img.remove();
          if (note.excerpt)
            card.createEl("p", { text: note.excerpt });
        };
      } else if (note.excerpt) {
        card.createEl("p", { text: note.excerpt });
      }
    } else if (note.excerpt) {
      card.createEl("p", { text: note.excerpt });
    }
    card.addEventListener("click", () => this.plugin.openNoteInNewTab(note.path));
    return card;
  }
  async buildContent() {
    this.mainContainer.addClass("easy-keep-view-main");
    if (!this.cardContainer) {
      this.cardContainer = this.mainContainer.createDiv("easy-keep-cards-container");
    } else {
      const existingCards = this.cardContainer.querySelectorAll(".easy-keep-card:not(.new-note-card)");
      existingCards.forEach((card) => card.remove());
    }
    let newNoteCard = this.cardContainer.querySelector(".new-note-card");
    if (!newNoteCard) {
      newNoteCard = this.cardContainer.createDiv("easy-keep-card new-note-card");
      newNoteCard.createEl("h3", { text: "+" });
      newNoteCard.createEl("p", { text: "Add new note" });
      newNoteCard.addEventListener("click", () => this.plugin.createNewNote());
    }
    this.cardContainer.insertBefore(newNoteCard, this.cardContainer.firstChild);
    await this.plugin.refreshThumbnails();
    const notes = this.plugin.settings.notesDB.slice().sort((a, b) => b.time - a.time).slice(0, 100);
    const currentPaths = /* @__PURE__ */ new Set();
    notes.forEach((note) => {
      currentPaths.add(note.path);
      const card = this.createOrUpdateCard(note);
      this.cardContainer.appendChild(card);
    });
    for (const [path, card] of this.cards) {
      if (!currentPaths.has(path)) {
        card.remove();
        this.cards.delete(path);
      }
    }
    let noHistory = this.cardContainer.querySelector(".no-history-message");
    if (notes.length === 0) {
      if (!noHistory) {
        noHistory = this.cardContainer.createDiv("no-history-message");
        noHistory.setText("No notes, create a new one!");
        if (newNoteCard && newNoteCard.nextSibling) {
          this.cardContainer.insertBefore(noHistory, newNoteCard.nextSibling);
        } else {
          this.cardContainer.appendChild(noHistory);
        }
      }
    } else if (noHistory) {
      noHistory.remove();
    }
  }
  async refreshContent() {
    if (!this.cardContainer) {
      await this.buildContent();
      return;
    }
    await this.buildContent();
  }
  async onOpen() {
    this.mainContainer = this.containerEl;
    await this.plugin.loadSettings();
    await this.buildContent();
  }
  async onClose() {
    this.cards.clear();
    this.cardContainer = null;
  }
};
var EasyKeepViewPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerView(VIEW_TYPE_EASY_KEEP, (leaf) => new EasyKeepView(leaf, this));
    this.app.workspace.onLayoutReady(async () => {
      await this.cleanDatabase();
      await this.refreshThumbnails();
      this.refreshEasyKeepViewIfOpen();
      if (this.settings.openAsHomepage) {
        await this.activateEasyKeepView();
      }
    });
    const ribbonIconEl = this.addRibbonIcon("sticky-note", "Easy keep view", () => {
      this.activateEasyKeepView();
    });
    this.addCommand({
      id: "open-easy-keep-view",
      name: "Open easy keep view",
      callback: () => this.activateEasyKeepView()
    });
    this.addCommand({
      id: "create-easy-keep-note",
      name: "Create new easy keep note",
      callback: () => this.createNewNote()
    });
    this.registerEvent(this.app.workspace.on("file-open", async (file) => {
      if (file) {
        await this.addToDatabase(file);
        this.refreshDebounced();
      }
    }));
    this.registerEvent(this.app.vault.on("delete", async (file) => {
      if (file instanceof import_obsidian2.TFile) {
        await this.removeFromDatabase(file.path);
        this.refreshDebounced();
      }
    }));
    this.registerEvent(this.app.vault.on("rename", async (file, oldPath) => {
      if (file instanceof import_obsidian2.TFile) {
        const entryIndex = this.settings.notesDB.findIndex((e) => e.path === oldPath);
        if (entryIndex !== -1) {
          this.settings.notesDB[entryIndex].path = file.path;
          this.settings.notesDB[entryIndex].title = file.basename;
          await this.saveSettings();
          this.refreshDebounced();
        }
      }
    }));
    this.registerEvent(this.app.vault.on("rename", async (file, oldPath) => {
      if (file instanceof import_obsidian2.TFile && /\.(jpg|jpeg|png|webp)$/i.test(file.path)) {
        let updated = false;
        this.settings.notesDB.forEach((entry) => {
          if (entry.imageLink === oldPath) {
            entry.imageLink = file.path;
            updated = true;
          }
        });
        if (updated) {
          await this.saveSettings();
          this.refreshDebounced();
        }
      }
    }));
    this.registerEvent(this.app.vault.on("modify", async (file) => {
      if (file instanceof import_obsidian2.TFile) {
        await this.addToDatabase(file);
        await this.refreshThumbnails();
        this.refreshDebounced();
      }
    }));
    this.refreshDebounced = (0, import_obsidian2.debounce)(() => this.refreshEasyKeepViewIfOpen(), 300);
    this.addSettingTab(new EasySettingTab(this.app, this));
  }
  async activateEasyKeepView() {
    const existingLeaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_EASY_KEEP);
    if (existingLeaves.length > 0) {
      const leaf2 = existingLeaves[0];
      this.app.workspace.revealLeaf(leaf2);
      const view2 = leaf2.view;
      await view2.refreshContent();
      requestAnimationFrame(() => {
        const cardContainer = view2.containerEl.querySelector(".easy-keep-cards-container");
        if (cardContainer) {
          cardContainer.scrollTop = 0;
        }
      });
      return;
    }
    const leaf = this.app.workspace.getLeaf(true);
    await leaf.setViewState({ type: VIEW_TYPE_EASY_KEEP, active: true });
    this.app.workspace.revealLeaf(leaf);
    const view = leaf.view;
    await view.refreshContent();
    requestAnimationFrame(() => {
      const cardContainer = view.containerEl.querySelector(".easy-keep-cards-container");
      if (cardContainer) {
        cardContainer.scrollTop = 0;
      }
    });
  }
  async refreshEasyKeepViewIfOpen() {
    const existingLeaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_EASY_KEEP);
    if (existingLeaves.length > 0) {
      const view = existingLeaves[0].view;
      await view.refreshContent();
    }
  }
  async refreshThumbnails() {
    for (const note of this.settings.notesDB) {
      const file = this.app.vault.getAbstractFileByPath(note.path);
      if (!(file instanceof import_obsidian2.TFile))
        continue;
      const content = await this.app.vault.cachedRead(file);
      const lines = content.trim().split("\n").filter((line) => line.trim() !== "");
      const firstLine = lines.find((line) => line.trim() !== "");
      let excerpt = "";
      let imageLink;
      if (firstLine && firstLine.includes("![[") && firstLine.includes("]]")) {
        excerpt = lines.slice(0, 1).join(" ");
      } else {
        if (firstLine) {
          excerpt = firstLine;
          if (lines.length > 1)
            excerpt += " \u2026";
        }
        const match = content.match(/!\[\[([^\]]+)\]\]/);
        if (match) {
          imageLink = match[1].trim();
          if (imageLink && note.imageLink !== imageLink) {
            note.imageLink = imageLink;
          }
        }
      }
      if (imageLink) {
        note.imageLink = imageLink;
      }
      if (excerpt) {
        note.excerpt = excerpt;
      }
    }
    await this.saveSettings();
  }
  async addToDatabase(file) {
    var _a;
    let excerpt = "";
    let imageLink;
    if (/\.(jpg|jpeg|png|webp)$/i.test(file.path)) {
      imageLink = file.path;
    } else {
      const content = await this.app.vault.cachedRead(file);
      const lines = content.trim().split("\n").filter((line) => line.trim() !== "");
      const obsidianEmbedMatch = content.match(/!\[\[([^\]]+)\]\]/);
      const markdownImageMatch = content.match(/!\[.*?\]\((.*?)\)/);
      if (obsidianEmbedMatch || markdownImageMatch) {
        imageLink = (_a = (obsidianEmbedMatch == null ? void 0 : obsidianEmbedMatch[1]) || (markdownImageMatch == null ? void 0 : markdownImageMatch[1])) == null ? void 0 : _a.trim();
      }
      if (lines.length > 0) {
        excerpt = lines.slice(0, 2).join(" ");
        if (lines.length > 2)
          excerpt = excerpt.trim() + " \u2026";
      }
    }
    const titleWithoutExt = file.name.replace(/\.(md|png|jpg|jpeg|webp)$/i, "");
    const newEntry = {
      path: file.path,
      title: titleWithoutExt,
      excerpt,
      time: Date.now(),
      imageLink
    };
    this.settings.notesDB = this.settings.notesDB.filter((entry) => entry.path !== file.path);
    this.settings.notesDB.unshift(newEntry);
    await this.saveSettings();
  }
  async removeFromDatabase(filePath) {
    const initialLength = this.settings.notesDB.length;
    this.settings.notesDB = this.settings.notesDB.filter((entry) => entry.path !== filePath);
    if (this.settings.notesDB.length !== initialLength) {
      await this.saveSettings();
    }
  }
  async cleanDatabase() {
    const files = this.app.vault.getFiles().filter(
      (file) => /\.(md|jpg|jpeg|png|webp)$/i.test(file.path)
    );
    const existingPaths = new Set(files.map((file) => file.path));
    this.settings.notesDB = this.settings.notesDB.filter((entry) => {
      if (!existingPaths.has(entry.path))
        return false;
      if (/\.(jpg|jpeg|png|webp)$/i.test(entry.path)) {
        entry.excerpt = "";
        entry.imageLink = entry.path;
      }
      return true;
    });
    await this.saveSettings();
  }
  async openNoteInNewTab(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian2.TFile)) {
      new import_obsidian2.Notice(`File not found: ${filePath}`);
      return;
    }
    let existingLeaf = null;
    this.app.workspace.iterateAllLeaves((leaf) => {
      const viewType = leaf.view.getViewType();
      const viewState = leaf.view.getState();
      if ((viewState == null ? void 0 : viewState.file) === filePath) {
        existingLeaf = leaf;
      }
    });
    if (existingLeaf) {
      this.app.workspace.setActiveLeaf(existingLeaf, { focus: true });
    } else {
      try {
        const newLeaf = this.app.workspace.getLeaf(true);
        await newLeaf.openFile(file);
        this.app.workspace.setActiveLeaf(newLeaf, { focus: true });
      } catch (error) {
        new import_obsidian2.Notice(`Cannot open ${file.name}: Unsupported format or error.`);
      }
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  generateUniqueUntitledName() {
    const baseName = "Untitled";
    const files = this.app.vault.getMarkdownFiles();
    const existingNames = new Set(files.map((f) => f.basename));
    if (!existingNames.has(baseName)) {
      return baseName;
    }
    let counter = 1;
    while (existingNames.has(`${baseName} ${counter}`)) {
      counter++;
    }
    return `${baseName} ${counter}`;
  }
  async createNewNote() {
    const title = this.generateUniqueUntitledName();
    const filePath = `${title}.md`;
    const file = await this.app.vault.create(filePath, "");
    await this.addToDatabase(file);
    this.openNoteInNewTab(filePath);
  }
};


/* nosourcemap */